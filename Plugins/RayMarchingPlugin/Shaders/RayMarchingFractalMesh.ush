#include  "/PluginShaders/SDFractalLibrary.ush"

SDFractal sdfLibrary;
float4 col = 0;
float3 pos = pWorldPosition;
float3 normal = 0;

pos = (pos - pObjectPosition) / pObjectScale * pScale;

int i = 0;

float Xcomponent = dot(pos, pRotMatRow1);
float Ycomponent = dot(pos, pRotMatRow2);
float Zcomponent = dot(pos, pRotMatRow3);
pos = float3(Xcomponent, Ycomponent, Zcomponent);

Xcomponent = dot(pCameraVector, pRotMatRow1);
Ycomponent = dot(pCameraVector, pRotMatRow2);
Zcomponent = dot(pCameraVector, pRotMatRow3);
pCameraVector = float3(Xcomponent, Ycomponent, Zcomponent);

float td = 0.0f;

for (i = 0; i < pMaxSteps; i++)
{
	float2 dist = sdfLibrary.sdByType(pos, pFractalType, pTime, 
	pIterations, pBailout, pPower, 
	pOffset, pFoldingScale, 0.0f, 
	pCameraVector, pScale, pOrbit.xyz, 
	pOrbitType, pOrbitOrigin);

	td += dist.x;

	if (td > pMaxDist)
	{
		break;
	}
    else if (dist.x * pObjectScale < pDisThreshold)
    {
        col = float4(1, 0, 0, 1);
    	IterationCount = dist.y * pScale;

		if (pUseNormals == 1.0f)
		{
    		normal = sdfLibrary.sdNormalByType(pos, pFractalType);

			float NXcomponent = dot(normal, float3(pRotMatRow1.x , pRotMatRow2.x, pRotMatRow3.x));
			float NYcomponent = dot(normal, float3(pRotMatRow1.y , pRotMatRow2.y, pRotMatRow3.y));
			float NZcomponent = dot(normal, float3(pRotMatRow1.z , pRotMatRow2.z, pRotMatRow3.z));
			normal = float3(NXcomponent, NYcomponent, NZcomponent);
		}
	
        break;
    }
    pos += pCameraVector * dist.x;
}

return float4(normal, col.a);