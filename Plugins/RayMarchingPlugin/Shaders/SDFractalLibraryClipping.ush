struct SDFractal
{
	float Iterations;
	float Bailout;
	float Power;
	float Offset;
	float FoldingScale;
	float Time;
	float R;
	float Scale;
	float OrbitType;

	float3 CameraVector;
	float3 Orbit;
	float3 OrbitOrigin;
	float3 FoldAngles;
	float3 FoldOffset;

	float2 sdByType(float3 pos, float pFractalType, float _Time, 
	float _Iterations, float _Bailout, float _Power, 
	float _Offset, float _FoldingScale, float _R,
	float3 _CameraVector, float _Scale, float3 _Orbit, float _OrbitType,
	float3 _OrbitOrigin, float3 _FoldAngles, float3 _FoldOffset)
	{
		Iterations = _Iterations;
		Bailout = _Bailout;
		Power = _Power;
		Offset = _Offset;
		FoldingScale = _FoldingScale;
		Time = _Time;
		R = _R;
		Scale = _Scale;
		OrbitType = _OrbitType;
		seed = 1.0f;

		CameraVector = _CameraVector;
		Orbit = _Orbit;
		OrbitOrigin = _OrbitOrigin;
		FoldAngles = _FoldAngles;
		FoldOffset = _FoldOffset;

		float2 dist = 0;
		
		if (pFractalType == 3.0)
		{
			dist = sdJulia2(pos);
		}

		return dist;
	}

	
	float3 sdNormalByType(float3 pos, float pFractalType)
	{
		float3 normal = 0;

		if (pFractalType == 3.0)
		{
			normal = sdJuliaNormal2(pos);	
		}

		return normal;
	}

	//##########################################
	//   Quaternions operations

	float4 qSqr(float4 a )
	{
	    return float4( a.x*a.x - a.y*a.y - a.z*a.z - a.w*a.w,
	                 2.0*a.x*a.y,
	                 2.0*a.x*a.z,
	                 2.0*a.x*a.w );
	}
	float4 qCube( float4 a )
	{
		return a * ( 4.0*a.x*a.x - dot(a,a)*float4(3.0,1.0,1.0,1.0) );
	}

	float4 qmul(float4 a, float4 b)
	{
	    return float4(
	        a.x * b.x - a.y * b.y - a.z * b.z - a.w * b.w,
	        a.y * b.x + a.x * b.y + a.z * b.w - a.w * b.z, 
	        a.z * b.x + a.x * b.z + a.w * b.y - a.y * b.w,
	        a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y );

	}
	float4 qconj(float4 a)
	{
	    return float4( a.x, -a.yzw );
	}
	float qlength2(float4 q)
	{
	    return dot(q,q);
	}
	float lengthSquared( float4 z ) { return dot(z,z); }

	//##########################################

	int   seed;
	int   PupSik_Rand() { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }
	float PupSik_Frand() { return float(PupSik_Rand())/32767.0; }

	float3 colorSurface(float3 pos, float3 nor, float2 tn )
	{
	    float3 col = 0.5+0.5*cos(log2(tn.y)*0.9+3.5+float3(0.0,0.6,1.0));
	    if( pos.y>0.0 ) col = lerp(col,float3(1.0, 1.0, 1.0),0.2);
	    float inside = smoothstep(14.0,15.0,tn.y);
	    col *= float3(0.45,0.42,0.40) + float3(0.55,0.58,0.60)*inside;
	    col = lerp(col*col*(3.0-2.0*col),col,inside);
	    col = lerp( lerp(col,float3(1.0, 1.0f, 1.0f) * dot(col,float3(0.3333, 0.3333, 0.3333)),-0.4),
	                        col, inside);
	    return clamp(col*0.65,0.0,1.0);
	}

	float sdPlane( float3 p, float3 n, float h )
	{
	  // n must be normalized
	  return dot(p,n) + h;
	}

	
	float qLength2(float4 q ) { return dot(q,q); }

	float4 qSquare(float4 q )
	{
	    return float4(q.x*q.x - q.y*q.y - q.z*q.z - q.w*q.w, 2.0*q.x*q.yzw);
	}

	float sdBox(float4 p, float3 s) {
		float3 q = abs(p) - s;
		return (min(max(max(q.y, q.z), q.x), 0.0) + length(max(q, 0.0))) / p.w;
	}

	float2 sdJulia2(float3 p)
	{
		float4  kC = float4(-2,6,15,-6)/22.0;
	    float4 z = float4( p, 0.0 );
	    float dz2 = 1.0;
		float m2  = 0.0;
	    float n   = 0.0;

	    for( int i=0; i<Iterations; i++ ) 
		{
	        // z' = 3z² -> |z'|² = 9|z²|²
			dz2 *= 9.0*lengthSquared(qSqr(z));
	        
	        // z = z³ + c		
			z = qCube( z ) + kC;
	        
	        // stop under divergence		
	        m2 = lengthSquared(z);		
	        // exit condition
	        if( m2>256.0 ) break;				 
			n += 1.0;
		}
	   
		// sdf(z) = log|z|·|z|/|dz| : https://iquilezles.org/articles/distancefractals
		float d = 0.25*log(m2)*sqrt(m2/dz2);

		float planeDist = sdBox(float4(p, 1.0), float3(0.5, 1.0, 1.0));
	    
		return float2(max(d, planeDist), n);        
	}

	float3 sdJuliaNormal2(float3 p) {
		float3 k = float3(1,-1,0);
		float dx = 0.01;

		return normalize(k.xyy * sdJulia2(p + k.xyyz*dx).x +
						 k.yyx * sdJulia2(p + k.yyxz*dx).x +
						 k.yxy * sdJulia2(p + k.yxyz*dx).x +
						 k.xxx * sdJulia2(p + k.xxxz*dx).x);
	}
};